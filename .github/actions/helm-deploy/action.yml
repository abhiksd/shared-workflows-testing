name: 'Helm Deploy'
description: 'Deploys applications to AKS using Helm charts'

inputs:
  environment:
    description: 'Target environment'
    required: true
  application_name:
    description: 'Application name'
    required: true
  application_type:
    description: 'Application type'
    required: true
  helm_chart_path:
    description: 'Path to Helm chart'
    required: true
  image_tag:
    description: 'Image tag'
    required: true
  helm_version:
    description: 'Helm chart version'
    required: true
  registry:
    description: 'Container registry'
    required: true
  aks_cluster_name:
    description: 'AKS cluster name'
    required: true
  aks_resource_group:
    description: 'AKS resource group'
    required: true
  azure_tenant_id:
    description: 'Azure Tenant ID for Key Vault'
    required: false
  azure_client_id:
    description: 'Azure Client ID (Managed Identity) for Key Vault'
    required: false
  keyvault_name:
    description: 'Azure Key Vault name'
    required: false

outputs:
  deployment_status:
    description: 'Deployment status'
    value: ${{ steps.deploy.outputs.status }}
  release_name:
    description: 'Helm release name'
    value: ${{ steps.deploy.outputs.release_name }}

runs:
  using: 'composite'
  steps:
    - name: Install Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'

    - name: Get AKS credentials
      uses: azure/aks-set-context@v3
      with:
        resource-group: ${{ inputs.aks_resource_group }}
        cluster-name: ${{ inputs.aks_cluster_name }}

    - name: Create namespace if not exists
      run: |
        NAMESPACE="${{ inputs.environment }}-${{ inputs.application_name }}"
        kubectl create namespace ${NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -
        kubectl label namespace ${NAMESPACE} environment=${{ inputs.environment }} --overwrite
        kubectl label namespace ${NAMESPACE} application=${{ inputs.application_name }} --overwrite
        echo "namespace=${NAMESPACE}" >> $GITHUB_OUTPUT
      shell: bash
      id: namespace

    - name: Prepare Helm values
      id: values
      run: |
        NAMESPACE="${{ steps.namespace.outputs.namespace }}"
        VALUES_FILE="${{ inputs.helm_chart_path }}/values-${{ inputs.environment }}.yaml"
        RUNTIME_VALUES_FILE="values-runtime-${{ inputs.environment }}.yaml"
        
        echo "ðŸ“ Using environment-specific values file: ${VALUES_FILE}"
        
        # Check if environment-specific values file exists
        if [ ! -f "${VALUES_FILE}" ]; then
          echo "âŒ Environment-specific values file not found: ${VALUES_FILE}"
          echo "ðŸ“‹ Available values files:"
          find ${{ inputs.helm_chart_path }} -name "values*.yaml" -type f
          exit 1
        fi
        
        # Create runtime values file with dynamic values
        cat > ${RUNTIME_VALUES_FILE} << EOF
        # Runtime values for ${{ inputs.environment }} - Auto-generated
        global:
          environment: ${{ inputs.environment }}
          applicationName: ${{ inputs.application_name }}
          applicationType: ${{ inputs.application_type }}
          
        image:
          repository: ${{ inputs.registry }}/${{ inputs.application_name }}
          tag: ${{ inputs.image_tag }}
          
        nameOverride: ${{ inputs.application_name }}
        fullnameOverride: ${{ inputs.application_name }}-${{ inputs.environment }}
        
        # Runtime environment variables
        env:
          - name: ENVIRONMENT
            value: ${{ inputs.environment }}
          - name: APPLICATION_NAME
            value: ${{ inputs.application_name }}
          - name: BUILD_VERSION
            value: ${{ inputs.image_tag }}
          - name: HELM_VERSION
            value: ${{ inputs.helm_version }}
        EOF
        
        # Add Azure Key Vault configuration if provided
        if [[ -n "${{ inputs.azure_tenant_id }}" && -n "${{ inputs.azure_client_id }}" && -n "${{ inputs.keyvault_name }}" ]]; then
          cat >> ${RUNTIME_VALUES_FILE} << EOF
        
        # Azure Key Vault configuration - Injected by GitHub Actions
        azureKeyVault:
          tenantId: "${{ inputs.azure_tenant_id }}"
          userAssignedIdentityID: "${{ inputs.azure_client_id }}"
          keyvaultName: "${{ inputs.keyvault_name }}"
        EOF
          echo "âœ… Azure Key Vault configuration added to runtime values"
        fi
        
        echo "values_file=${VALUES_FILE}" >> $GITHUB_OUTPUT
        echo "runtime_values_file=${RUNTIME_VALUES_FILE}" >> $GITHUB_OUTPUT
        
        echo "âœ… Values files prepared successfully"
        echo "ðŸ“„ Environment-specific values:"
        head -20 ${VALUES_FILE}
        echo "..."
        echo "ðŸ“„ Runtime values:"
        cat ${RUNTIME_VALUES_FILE}
      shell: bash

    - name: Lint Helm chart
      run: |
        helm lint ${{ inputs.helm_chart_path }} \
          -f ${{ steps.values.outputs.values_file }} \
          -f ${{ steps.values.outputs.runtime_values_file }}
      shell: bash

    - name: Deploy with Helm
      id: deploy
      run: |
        NAMESPACE="${{ steps.namespace.outputs.namespace }}"
        RELEASE_NAME="${{ inputs.application_name }}-${{ inputs.environment }}"
        
        echo "Deploying ${RELEASE_NAME} to namespace ${NAMESPACE}"
        
        # Check if release exists
        if helm list -n ${NAMESPACE} | grep -q ${RELEASE_NAME}; then
          echo "Upgrading existing release..."
          helm upgrade ${RELEASE_NAME} ${{ inputs.helm_chart_path }} \
            --namespace ${NAMESPACE} \
            --values ${{ steps.values.outputs.values_file }} \
            --values ${{ steps.values.outputs.runtime_values_file }} \
            --version ${{ inputs.helm_version }} \
            --wait \
            --timeout 600s \
            --atomic
        else
          echo "Installing new release..."
          helm install ${RELEASE_NAME} ${{ inputs.helm_chart_path }} \
            --namespace ${NAMESPACE} \
            --values ${{ steps.values.outputs.values_file }} \
            --values ${{ steps.values.outputs.runtime_values_file }} \
            --version ${{ inputs.helm_version }} \
            --wait \
            --timeout 600s \
            --atomic
        fi
        
        echo "release_name=${RELEASE_NAME}" >> $GITHUB_OUTPUT
        echo "status=success" >> $GITHUB_OUTPUT
        
        # Get deployment status
        kubectl get pods -n ${NAMESPACE} -l app.kubernetes.io/name=${{ inputs.application_name }}
        kubectl get svc -n ${NAMESPACE} -l app.kubernetes.io/name=${{ inputs.application_name }}
        
        echo "Deployment completed successfully!"
      shell: bash

    - name: Run deployment tests
      run: |
        NAMESPACE="${{ steps.namespace.outputs.namespace }}"
        RELEASE_NAME="${{ steps.deploy.outputs.release_name }}"
        
        # Run Helm test if tests exist
        if helm test ${RELEASE_NAME} --namespace ${NAMESPACE} --timeout 300s; then
          echo "Helm tests passed"
        else
          echo "Helm tests failed or not available"
        fi
        
        # Wait for deployment to be ready
        kubectl wait --for=condition=available deployment/${RELEASE_NAME} -n ${NAMESPACE} --timeout=300s
        
        echo "Deployment is ready and healthy"
      shell: bash

    - name: Generate deployment summary
      run: |
        NAMESPACE="${{ steps.namespace.outputs.namespace }}"
        RELEASE_NAME="${{ steps.deploy.outputs.release_name }}"
        
        cat >> $GITHUB_STEP_SUMMARY << EOF
        ## ðŸš€ Deployment Summary
        
        **Application:** ${{ inputs.application_name }}
        **Environment:** ${{ inputs.environment }}
        **Image Tag:** ${{ inputs.image_tag }}
        **Helm Chart Version:** ${{ inputs.helm_version }}
        **Namespace:** ${NAMESPACE}
        **Release Name:** ${RELEASE_NAME}
        
        ### Deployment Status
        \`\`\`
        $(kubectl get pods -n ${NAMESPACE} -l app.kubernetes.io/name=${{ inputs.application_name }})
        \`\`\`
        
        ### Service Information
        \`\`\`
        $(kubectl get svc -n ${NAMESPACE} -l app.kubernetes.io/name=${{ inputs.application_name }})
        \`\`\`
        EOF
      shell: bash