name: 'Helm Deploy'
description: 'Deploys applications to AKS using Helm charts'

inputs:
  environment:
    description: 'Target environment'
    required: true
  application_name:
    description: 'Application name'
    required: true
  application_type:
    description: 'Application type'
    required: true
  helm_chart_path:
    description: 'Path to Helm chart'
    required: true
  image_tag:
    description: 'Image tag'
    required: true
  helm_version:
    description: 'Helm chart version'
    required: true
  registry:
    description: 'Container registry'
    required: true
  aks_cluster_name:
    description: 'AKS cluster name'
    required: true
  aks_resource_group:
    description: 'AKS resource group'
    required: true
  azure_tenant_id:
    description: 'Azure Tenant ID for Key Vault'
    required: false
  azure_client_id:
    description: 'Azure Client ID (App Registration) for OIDC authentication'
    required: false
  azure_subscription_id:
    description: 'Azure Subscription ID for OIDC authentication'
    required: false
  keyvault_name:
    description: 'Azure Key Vault name'
    required: false
  deployment_context:
    description: 'JSON deployment context with environment and application details'
    required: false

outputs:
  deployment_status:
    description: 'Deployment status'
    value: ${{ steps.deploy.outputs.status }}
  release_name:
    description: 'Helm release name'
    value: ${{ steps.deploy.outputs.release_name }}
  namespace:
    description: 'Kubernetes namespace'
    value: ${{ steps.namespace.outputs.namespace }}

runs:
  using: 'composite'
  steps:
    - name: Initialize deployment logging
      run: |
        echo "ðŸš€ Helm Deployment Action Started"
        echo "==============================================================="
        
        # Parse deployment context if provided
        if [[ -n "${{ inputs.deployment_context }}" ]]; then
          echo "ðŸ“‹ Deployment Context:"
          echo '${{ inputs.deployment_context }}' | jq '.'
          echo ""
          
          # Extract context information for enhanced logging
          APP_NAME=$(echo '${{ inputs.deployment_context }}' | jq -r '.application // "${{ inputs.application_name }}"')
          ENV_NAME=$(echo '${{ inputs.deployment_context }}' | jq -r '.environment // "${{ inputs.environment }}"')
          TIMESTAMP=$(echo '${{ inputs.deployment_context }}' | jq -r '.timestamp // "N/A"')
          
          echo "ðŸŽ¯ Deployment initiated for:"
          echo "   - Application: $APP_NAME"
          echo "   - Environment: $ENV_NAME"
          echo "   - Timestamp: $TIMESTAMP"
        else
          echo "ðŸ“ Basic deployment information:"
          echo "   - Application: ${{ inputs.application_name }}"
          echo "   - Environment: ${{ inputs.environment }}"
        fi
        echo ""
      shell: bash

    - name: Validate required parameters
      run: |
        echo "ðŸ” Validating AKS deployment parameters..."
        echo "==============================================================="
        
        VALIDATION_FAILED=false
        
        # Check required parameters with enhanced logging
        if [ -z "${{ inputs.aks_resource_group }}" ]; then
          echo "âŒ ERROR: aks_resource_group is empty or not provided"
          echo "   This usually means:"
          echo "   - AKS_ENVIRONMENTS_CONFIG secret is not properly formatted"
          echo "   - Environment detection failed in shared workflow"
          echo "   - validate-environment job didn't set outputs correctly"
          VALIDATION_FAILED=true
        else
          echo "âœ… AKS Resource Group: ${{ inputs.aks_resource_group }}"
        fi
        
        if [ -z "${{ inputs.aks_cluster_name }}" ]; then
          echo "âŒ ERROR: aks_cluster_name is empty or not provided"
          VALIDATION_FAILED=true
        else
          echo "âœ… AKS Cluster Name: ${{ inputs.aks_cluster_name }}"
        fi
        
        if [ -z "${{ inputs.azure_client_id }}" ]; then
          echo "âŒ ERROR: azure_client_id is empty or not provided"
          VALIDATION_FAILED=true
        else
          echo "âœ… Azure Client ID: ${{ inputs.azure_client_id }}"
        fi
        
        if [ -z "${{ inputs.azure_tenant_id }}" ]; then
          echo "âŒ ERROR: azure_tenant_id is empty or not provided"
          VALIDATION_FAILED=true
        else
          echo "âœ… Azure Tenant ID: ${{ inputs.azure_tenant_id }}"
        fi
        
        if [ -z "${{ inputs.azure_subscription_id }}" ]; then
          echo "âŒ ERROR: azure_subscription_id is empty or not provided"
          VALIDATION_FAILED=true
        else
          echo "âœ… Azure Subscription ID: ${{ inputs.azure_subscription_id }}"
        fi
        
        if [ "$VALIDATION_FAILED" = true ]; then
          echo ""
          echo "âŒ Parameter validation failed - cannot proceed with deployment"
          exit 1
        fi
        
        echo ""
        echo "âœ… All required parameters validated successfully"
        echo "ðŸŽ¯ Deployment target: ${{ inputs.aks_cluster_name }} in ${{ inputs.aks_resource_group }}"
        echo ""
      shell: bash

    - name: Azure Login with OIDC
      uses: azure/login@v2
      with:
        client-id: ${{ inputs.azure_client_id }}
        tenant-id: ${{ inputs.azure_tenant_id }}
        subscription-id: ${{ inputs.azure_subscription_id }}

    - name: Install Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'

    - name: Get AKS credentials
      run: |
        echo "ðŸ” Obtaining AKS cluster credentials..."
        echo "   - Cluster: ${{ inputs.aks_cluster_name }}"
        echo "   - Resource Group: ${{ inputs.aks_resource_group }}"
        echo ""
      shell: bash

    - name: Configure AKS context
      uses: azure/aks-set-context@v3
      with:
        resource-group: ${{ inputs.aks_resource_group }}
        cluster-name: ${{ inputs.aks_cluster_name }}

    - name: Verify cluster connectivity
      run: |
        echo "ðŸ”— Verifying AKS cluster connectivity..."
        
        # Test cluster connection
        if kubectl cluster-info; then
          echo "âœ… Successfully connected to AKS cluster"
        else
          echo "âŒ Failed to connect to AKS cluster"
          exit 1
        fi
        
        # Log cluster information
        echo ""
        echo "ðŸ“Š Cluster Information:"
        kubectl version --short || true
        echo ""
      shell: bash

    - name: Create namespace if not exists
      run: |
        NAMESPACE="${{ inputs.environment }}-${{ inputs.application_name }}"
        
        echo "ðŸ—ï¸  Setting up Kubernetes namespace..."
        echo "   - Namespace: $NAMESPACE"
        echo "   - Environment: ${{ inputs.environment }}"
        echo "   - Application: ${{ inputs.application_name }}"
        echo ""
        
        # Create namespace with labels
        kubectl create namespace ${NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -
        kubectl label namespace ${NAMESPACE} environment=${{ inputs.environment }} --overwrite
        kubectl label namespace ${NAMESPACE} application=${{ inputs.application_name }} --overwrite
        kubectl label namespace ${NAMESPACE} managed-by=github-actions --overwrite
        
        # Add deployment context as annotation if available
        if [[ -n "${{ inputs.deployment_context }}" ]]; then
          kubectl annotate namespace ${NAMESPACE} \
            deployment-context='${{ inputs.deployment_context }}' --overwrite
        fi
        
        echo "âœ… Namespace $NAMESPACE configured successfully"
        echo "namespace=${NAMESPACE}" >> $GITHUB_OUTPUT
        echo ""
      shell: bash
      id: namespace

    - name: Prepare Helm values
      id: values
      run: |
        NAMESPACE="${{ steps.namespace.outputs.namespace }}"
        VALUES_FILE="${{ inputs.helm_chart_path }}/values-${{ inputs.environment }}.yaml"
        RUNTIME_VALUES_FILE="values-runtime-${{ inputs.environment }}.yaml"
        
        echo "ðŸ“ Preparing Helm values configuration..."
        echo "   - Environment: ${{ inputs.environment }}"
        echo "   - Values file: ${VALUES_FILE}"
        echo "   - Runtime values: ${RUNTIME_VALUES_FILE}"
        echo ""
        
        # Check if environment-specific values file exists
        if [ ! -f "${VALUES_FILE}" ]; then
          echo "âŒ Environment-specific values file not found: ${VALUES_FILE}"
          echo ""
          echo "ðŸ“‹ Available values files:"
          find ${{ inputs.helm_chart_path }} -name "values*.yaml" -type f
          exit 1
        fi
        
        echo "âœ… Environment values file found: ${VALUES_FILE}"
        
        # Create runtime values file with dynamic values
        cat > ${RUNTIME_VALUES_FILE} << EOF
        # Runtime values for ${{ inputs.environment }} - Auto-generated by GitHub Actions
        global:
          environment: ${{ inputs.environment }}
          applicationName: ${{ inputs.application_name }}
          applicationType: ${{ inputs.application_type }}
          deploymentTimestamp: "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          
        image:
          repository: ${{ inputs.registry }}/${{ inputs.application_name }}
          tag: ${{ inputs.image_tag }}
          
        nameOverride: ${{ inputs.application_name }}
        fullnameOverride: ${{ inputs.application_name }}-${{ inputs.environment }}
        
        # Runtime environment variables
        env:
          - name: ENVIRONMENT
            value: ${{ inputs.environment }}
          - name: APPLICATION_NAME
            value: ${{ inputs.application_name }}
          - name: BUILD_VERSION
            value: ${{ inputs.image_tag }}
          - name: HELM_VERSION
            value: ${{ inputs.helm_version }}
          - name: DEPLOYMENT_NAMESPACE
            value: ${NAMESPACE}
        EOF
        
        # Add Azure Key Vault configuration if provided
        if [[ -n "${{ inputs.azure_tenant_id }}" && -n "${{ inputs.azure_client_id }}" && -n "${{ inputs.keyvault_name }}" ]]; then
          cat >> ${RUNTIME_VALUES_FILE} << EOF
        
        # Azure Key Vault configuration - Injected by GitHub Actions
        azureKeyVault:
          tenantId: "${{ inputs.azure_tenant_id }}"
          userAssignedIdentityID: "${{ inputs.azure_client_id }}"
          keyvaultName: "${{ inputs.keyvault_name }}"
        EOF
          echo "âœ… Azure Key Vault configuration added to runtime values"
        fi
        
        # Add deployment context if available
        if [[ -n "${{ inputs.deployment_context }}" ]]; then
          DEPLOYMENT_BRANCH=$(echo '${{ inputs.deployment_context }}' | jq -r '.branch // "unknown"')
          DEPLOYMENT_EVENT=$(echo '${{ inputs.deployment_context }}' | jq -r '.event // "unknown"')
          
          cat >> ${RUNTIME_VALUES_FILE} << EOF
        
        # Deployment metadata from GitHub Actions
        deploymentMetadata:
          branch: "${DEPLOYMENT_BRANCH}"
          event: "${DEPLOYMENT_EVENT}"
          workflowRun: "${{ github.run_id }}"
          gitSha: "${{ github.sha }}"
        EOF
          echo "âœ… Deployment metadata added to runtime values"
        fi
        
        echo "values_file=${VALUES_FILE}" >> $GITHUB_OUTPUT
        echo "runtime_values_file=${RUNTIME_VALUES_FILE}" >> $GITHUB_OUTPUT
        
        echo ""
        echo "ðŸ“„ Environment-specific values (first 20 lines):"
        echo "==============================================================="
        head -20 ${VALUES_FILE}
        echo "..."
        echo ""
        echo "ðŸ“„ Runtime values:"
        echo "==============================================================="
        cat ${RUNTIME_VALUES_FILE}
        echo ""
      shell: bash

    - name: Lint Helm chart
      run: |
        echo "ðŸ” Linting Helm chart..."
        echo "   - Chart path: ${{ inputs.helm_chart_path }}"
        echo "   - Values files: ${{ steps.values.outputs.values_file }}, ${{ steps.values.outputs.runtime_values_file }}"
        echo ""
        
        if helm lint ${{ inputs.helm_chart_path }} \
          -f ${{ steps.values.outputs.values_file }} \
          -f ${{ steps.values.outputs.runtime_values_file }}; then
          echo "âœ… Helm chart lint passed"
        else
          echo "âŒ Helm chart lint failed"
          exit 1
        fi
        echo ""
      shell: bash

    - name: Deploy with Helm
      id: deploy
      run: |
        NAMESPACE="${{ steps.namespace.outputs.namespace }}"
        RELEASE_NAME="${{ inputs.application_name }}-${{ inputs.environment }}"
        
        echo "ðŸš€ Starting Helm deployment..."
        echo "==============================================================="
        echo "   - Release: $RELEASE_NAME"
        echo "   - Namespace: $NAMESPACE"
        echo "   - Chart: ${{ inputs.helm_chart_path }}"
        echo "   - Version: ${{ inputs.helm_version }}"
        echo "   - Image: ${{ inputs.registry }}/${{ inputs.application_name }}:${{ inputs.image_tag }}"
        echo ""
        
        # Check if release exists
        if helm list -n ${NAMESPACE} | grep -q ${RELEASE_NAME}; then
          echo "ðŸ“¦ Existing release found - performing upgrade..."
          helm upgrade ${RELEASE_NAME} ${{ inputs.helm_chart_path }} \
            --namespace ${NAMESPACE} \
            --values ${{ steps.values.outputs.values_file }} \
            --values ${{ steps.values.outputs.runtime_values_file }} \
            --version ${{ inputs.helm_version }} \
            --wait \
            --timeout 600s \
            --atomic \
            --history-max 10
          echo "âœ… Helm upgrade completed successfully"
        else
          echo "ðŸ†• New deployment - performing installation..."
          helm install ${RELEASE_NAME} ${{ inputs.helm_chart_path }} \
            --namespace ${NAMESPACE} \
            --values ${{ steps.values.outputs.values_file }} \
            --values ${{ steps.values.outputs.runtime_values_file }} \
            --version ${{ inputs.helm_version }} \
            --wait \
            --timeout 600s \
            --atomic
          echo "âœ… Helm installation completed successfully"
        fi
        
        echo "release_name=${RELEASE_NAME}" >> $GITHUB_OUTPUT
        echo "status=success" >> $GITHUB_OUTPUT
        
        echo ""
        echo "ðŸ” Post-deployment verification..."
        echo "==============================================================="
        
        # Get deployment status
        echo "ðŸ“‹ Pods status:"
        kubectl get pods -n ${NAMESPACE} -l app.kubernetes.io/name=${{ inputs.application_name }} || true
        
        echo ""
        echo "ðŸ“‹ Services status:"
        kubectl get svc -n ${NAMESPACE} -l app.kubernetes.io/name=${{ inputs.application_name }} || true
        
        echo ""
        echo "ðŸ“‹ Helm release status:"
        helm status ${RELEASE_NAME} -n ${NAMESPACE} || true
        
        echo ""
        echo "âœ… Deployment verification completed"
      shell: bash

    - name: Run deployment tests
      run: |
        NAMESPACE="${{ steps.namespace.outputs.namespace }}"
        RELEASE_NAME="${{ steps.deploy.outputs.release_name }}"
        
        echo "ðŸ§ª Running deployment tests and health checks..."
        echo "==============================================================="
        
        # Run Helm test if tests exist
        echo "ðŸ”¬ Running Helm tests..."
        if helm test ${RELEASE_NAME} --namespace ${NAMESPACE} --timeout 300s; then
          echo "âœ… Helm tests passed"
        else
          echo "âš ï¸  Helm tests failed or not available (this may be expected)"
        fi
        
        echo ""
        echo "â³ Waiting for deployment to be ready..."
        
        # Wait for deployment to be ready
        if kubectl wait --for=condition=available deployment/${RELEASE_NAME} -n ${NAMESPACE} --timeout=300s; then
          echo "âœ… Deployment is ready and healthy"
        else
          echo "âŒ Deployment failed to become ready within timeout"
          
          # Show debug information
          echo ""
          echo "ðŸ” Debug information:"
          kubectl describe deployment/${RELEASE_NAME} -n ${NAMESPACE} || true
          kubectl get events -n ${NAMESPACE} --sort-by='.lastTimestamp' | tail -10 || true
          exit 1
        fi
        
        echo ""
        echo "âœ… All deployment tests completed successfully"
      shell: bash

    - name: Generate deployment summary
      run: |
        NAMESPACE="${{ steps.namespace.outputs.namespace }}"
        RELEASE_NAME="${{ steps.deploy.outputs.release_name }}"
        
        echo "ðŸ“Š Generating deployment summary..."
        echo ""
        
        # Environment-specific success message
        case "${{ inputs.environment }}" in
          "dev")
            echo "ðŸ§ª Development deployment completed successfully!"
            ;;
          "staging")
            echo "ðŸŽ­ Staging deployment completed successfully!"
            ;;
          "production")
            echo "ðŸ­ Production deployment completed successfully!"
            ;;
          *)
            echo "ðŸš€ Deployment completed successfully!"
            ;;
        esac
        
        cat >> $GITHUB_STEP_SUMMARY << EOF
        ## ðŸš€ Deployment Summary
        
        **Application:** ${{ inputs.application_name }}  
        **Environment:** ${{ inputs.environment }}  
        **Image Tag:** ${{ inputs.image_tag }}  
        **Helm Chart Version:** ${{ inputs.helm_version }}  
        **Namespace:** ${NAMESPACE}  
        **Release Name:** ${RELEASE_NAME}  
        **AKS Cluster:** ${{ inputs.aks_cluster_name }}  
        **Resource Group:** ${{ inputs.aks_resource_group }}  
        
        ### ðŸ“‹ Deployment Status
        \`\`\`
        $(kubectl get pods -n ${NAMESPACE} -l app.kubernetes.io/name=${{ inputs.application_name }} 2>/dev/null || echo "No pods found")
        \`\`\`
        
        ### ðŸŒ Service Information  
        \`\`\`
        $(kubectl get svc -n ${NAMESPACE} -l app.kubernetes.io/name=${{ inputs.application_name }} 2>/dev/null || echo "No services found")
        \`\`\`
        
        ### âš¡ Helm Release Info
        \`\`\`
        $(helm list -n ${NAMESPACE} | grep ${RELEASE_NAME} || echo "Release not found")
        \`\`\`
        EOF
        
        echo "âœ… Deployment summary generated and added to workflow summary"
      shell: bash